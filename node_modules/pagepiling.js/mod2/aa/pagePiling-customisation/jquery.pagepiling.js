/** * pagepiling.js customization. * * https://github.com/alvarotrigo/pagePiling.js * * Copyright (C) 2015 alvarotrigo.com - A project by Alvaro Trigo */(function ($, document, window, undefined) {    'use strict';    var WRAPPER =               'pagepiling-wrapper';    var WRAPPER_SEL =           '.' + WRAPPER;    //util    var RESPONSIVE =            'pp-responsive';    var NO_TRANSITION =         'fp-notransition';    var DESTROYED =             'pp-destroyed';    var ACTIVE =                'active';    var ACTIVE_SEL =            '.' + ACTIVE;    var ENABLED =               'pp-enabled';    var VIEWING_PREFIX =        'pp-viewing';    var TABLE =                 'pp-table';    // section    var SECTION_DEFAULT_SEL =   '.section';    var SECTION =               'pp-section';    var SECTION_SEL =           '.' + SECTION;    var SECTION_ACTIVE_SEL =    SECTION_SEL + ACTIVE_SEL;    var SECTION_FIRST_SEL =     SECTION_SEL + ':first';    var SECTION_LAST_SEL =      SECTION_SEL + ':last';    var TABLE_CELL =            'pp-tableCell';    var TABLE_CELL_SEL =        '.' + TABLE_CELL;    // section nav    var SECTION_NAV =           'pp-nav';    var SECTION_NAV_SEL =       '#' + SECTION_NAV;    var SECTION_NAV_TOOLTIP =   'pp-tooltip';    var SECTION_NAV_TOOLTIP_SEL =   '.pp-tooltip';    var SHOW_ACTIVE_TOOLTIP =   'pp-show-active';    // slide    var SLIDE_DEFAULT_SEL =     '.slide';    var SLIDE =                 'pp-slide';    var SLIDE_SEL =             '.' + SLIDE;    var SLIDE_ACTIVE_SEL =      SLIDE_SEL + ACTIVE_SEL;    var SLIDES_WRAPPER =        'pp-slides';    var SLIDES_WRAPPER_SEL =    '.' + SLIDES_WRAPPER;    var SLIDES_CONTAINER =      'pp-slidesContainer';    var SLIDES_CONTAINER_SEL =  '.' + SLIDES_CONTAINER;    // slide nav    var SLIDES_NAV =            'pp-slidesNav';    var SLIDES_NAV_SEL =        '.' + SLIDES_NAV;    var SLIDES_NAV_LINK_SEL =   SLIDES_NAV_SEL + ' a';    var SLIDES_ARROW =          'pp-controlArrow';    var SLIDES_ARROW_SEL =      '.' + SLIDES_ARROW;    var SLIDES_PREV =           'pp-prev';    var SLIDES_PREV_SEL =       '.' + SLIDES_PREV;    var SLIDES_ARROW_PREV =     SLIDES_ARROW + ' ' + SLIDES_PREV;    var SLIDES_ARROW_PREV_SEL = SLIDES_ARROW_SEL + SLIDES_PREV_SEL;    var SLIDES_NEXT =           'pp-next';    var SLIDES_NEXT_SEL =       '.' + SLIDES_NEXT;    var SLIDES_ARROW_NEXT =     SLIDES_ARROW + ' ' + SLIDES_NEXT;    var SLIDES_ARROW_NEXT_SEL = SLIDES_ARROW_SEL + SLIDES_NEXT_SEL;    var $window = $(window);    var $document = $(document);    $.fn.pagepiling = function (custom) {         // common jQuery objects        var $htmlBody = $('html, body');        var $body = $('body');        var PP = $.fn.pagepiling;        var container = $(this);        var lastScrolledDestiny;        var lastScrolledSlide;        var lastAnimation = 0;        var isTouch = (('ontouchstart' in window) || (navigator.msMaxTouchPoints > 0) || (navigator.maxTouchPoints));        var touchStartY = 0, touchStartX = 0, touchEndY = 0, touchEndX = 0;        var slideMoving = false;        var movementType = new normalMovement();        var initialSection = $(SECTION_ACTIVE_SEL);        var initialSlide = initialSection.find(SLIDE_ACTIVE_SEL);        var initialUrl;        var isLandingPage = false;        //timeouts        var resizeId;        var afterSectionLoadsId;        var afterSlideLoadsId;        var scrollId;        var scrollId2;        //Defines the delay to take place before being able to scroll to the next section        //BE CAREFUL! Not recommened to change it under 400 for a good behavior in laptops and        //Apple devices (laptops, mouses...)        var scrollDelay = 600;        // Create some defaults, extending them with any options that were provided        var options = $.extend(true, {            type: 'normal',            direction: 'vertical',            menu: null,            verticalCentered: true,            sectionsColor: [],            anchors: [],            lockAnchors: false,            scrollingSpeed: 1000,            autoScrolling: true,            fitToSection: true,            fitToSectionDelay: 1000,            easing: 'easeInQuart',            easingcss3: 'cubic-bezier(0.550, 0.085, 0.000, 0.990)',            loopBottom: false,            loopHorizontal: true,            loopTop: false,            css3: true,            navigation: {                textColor: '#fff',                bulletsColor: '#000',                position: 'right',                tooltips: []            },            slidesNavigation: false,            slidesNavPosition: 'bottom',            normalScrollElements: null,            normalScrollElementTouchThreshold: 5,            touchSensitivity: 5,            sectionSelector: '.section',            slideSelector: SLIDE_DEFAULT_SEL,            controlArrows: true,            //Accessibility            keyboardScrolling: true,            animateAnchor: false,            recordHistory: true,            responsiveWidth: 0,            responsiveHeight: 0,            //events            afterLoad: null,            onLeave: null,            afterRender: null,            afterResize: null,            afterSlideLoad: null,            onSlideLeave: null        }, custom);        var originals = $.extend(true, {}, options); //deep copy        //easeInQuart animation included in the plugin        $.extend($.easing,{ easeInQuart: function (x, t, b, c, d) { return c*(t/=d)*t*t*t + b; }});        if(options.type == 'inverted'){            movementType = new invertedMovement();        }        /**        * Sets the autoScroll option.        * It changes the scroll bar visibility and the history of the site as a result.        */        PP.setAutoScrolling = function(value, type){            setVariableState('autoScrolling', value, type);            var activeSection = $(SECTION_ACTIVE_SEL);            var sectionAnchor = getSectionAnchor(activeSection);            if(options.autoScrolling && !options.scrollBar){                $htmlBody.css({                    'overflow' : 'hidden',                    'height' : '100%'                });                PP.setRecordHistory(originals.recordHistory, 'internal');                //for IE touch devices                container.css({                    '-ms-touch-action': 'none',                    'touch-action': 'none'                });                //removing the possible `relative` position                $(SECTION_SEL).css('position', '');                //in case it was not at the top                container.scrollTop(0);                //setting the fist section as the active one as it is in the viewport                movementType.getTopLayer().addClass('active').siblings().removeClass('active');                if(activeSection.length){                    //moving the container up                    PP.silentMoveTo(sectionAnchor);                }            }else{                $htmlBody.css({                    'overflow' : 'visible',                    'height' : '100%'                });                PP.setRecordHistory(false, 'internal');                //for IE touch devices                container.css({                    '-ms-touch-action': '',                    'touch-action': '',                    'overflow': 'visible'                });                setNeutralPosition();                $(SECTION_SEL).css('position', 'relative');                //in case it was not at the top                container.scrollTop(0);                //scrolling the page to the section with no animation                if (activeSection.length) {                    $htmlBody.scrollTop(activeSection.position().top);                }            }        };        function setNeutralPosition(){            $(SECTION_SEL).each(function(){                silentScroll($(this), '0%');            });        }        /**        * Defines wheter to record the history for each hash change in the URL.        */        PP.setRecordHistory = function(value, type){            setVariableState('recordHistory', value, type);        };        /**        * Defines the scrolling speed        */        PP.setScrollingSpeed = function(value, type){           setVariableState('scrollingSpeed', value, type);        };        /**        * Sets fitToSection        */        PP.setFitToSection = function(value, type){            setVariableState('fitToSection', value, type);        };        /**        * Sets lockAnchors        */        PP.setLockAnchors = function(value){            options.lockAnchors = value;        };        /**        * Adds or remove the possiblity of scrolling through sections by using the mouse wheel or the trackpad.        */        PP.setMouseWheelScrolling = function (value){            if(value){                addMouseWheelHandler();            }else{                removeMouseWheelHandler();            }        };        /**        * Adds or remove the possiblity of scrolling through sections by using the mouse wheel/trackpad or touch gestures.        */        PP.setAllowScrolling = function (value){            if(value){                PP.setMouseWheelScrolling(true);                addTouchHandler();            }else{                PP.setMouseWheelScrolling(false);                removeTouchHandler();            }        };        /**        * Adds or remove the possiblity of scrolling through sections by using the keyboard arrow keys        */        PP.setKeyboardScrolling = function (value){            options.keyboardScrolling = value;        };        /**        * Moves sectio up        */        PP.moveSectionUp = function () {            var prev = $(SECTION_ACTIVE_SEL).prev(SECTION_SEL);            //looping to the bottom if there's no more sections above            if (!prev.length && options.loopTop) {                prev = $(SECTION_SEL).last();            }            if (prev.length) {                scrollPage(prev);            }        };        /**        * Moves sectio down        */        PP.moveSectionDown = function () {            var next = $(SECTION_ACTIVE_SEL).next(SECTION_SEL);            //looping to the top if there's no more sections below            if(!next.length && options.loopBottom){                next = $(SECTION_SEL).first();            }            if (next.length) {                scrollPage(next);            }        };        /**        * Moves the page to the given section and slide with no animation.        * Anchors or index positions can be used as params.        */        PP.silentMoveTo = function(sectionAnchor, slideAnchor){            PP.setScrollingSpeed (0, 'internal');            PP.moveTo(sectionAnchor, slideAnchor)            PP.setScrollingSpeed (originals.scrollingSpeed, 'internal');        };        /**        * Moves the page to the given section and slide.        * Anchors or index positions can be used as params.        */        PP.moveTo = function (sectionAnchor, slideAnchor){            var destiny = getSectionByAnchor(sectionAnchor);            if (typeof slideAnchor !== 'undefined'){                scrollPageAndSlide(sectionAnchor, slideAnchor);            }else if(destiny.length > 0){                scrollPage(destiny);            }        };        /**        * Slides right the slider of the active section.        */        PP.moveSlideRight = function(){            moveSlide('next');        };        /**        * Slides left the slider of the active section.        */        PP.moveSlideLeft = function(){            moveSlide('prev');        };        /**        * Turns fullPage.js to normal scrolling mode when the viewport `width` or `height`        * are smaller than the set limit values.        */        PP.setResponsive = function (active){            var isResponsive = container.hasClass(RESPONSIVE);            if(active){                if(!isResponsive){                    PP.setAutoScrolling(false, 'internal');                    PP.setFitToSection(false, 'internal');                    $(SECTION_NAV_SEL).hide();                    container.addClass(RESPONSIVE);                }            }            else if(isResponsive){                PP.setAutoScrolling(originals.autoScrolling, 'internal');                PP.setFitToSection(originals.autoScrolling, 'internal');                $(SECTION_NAV_SEL).show();                container.removeClass(RESPONSIVE);            }        }        //adding internal class names to void problem with common ones        addInternalSelectors();        //if css3 is not supported, it will use jQuery animations        if(options.css3){            options.css3 = support3d();        }        container.removeClass(DESTROYED); //in case it was destroyed before initilizing it again        $(container).css({            'overflow' : 'hidden',            '-ms-touch-action': 'none',  /* Touch detection for Windows 8 */            'touch-action': 'none'       /* IE 11 on Windows Phone 8.1*/        });        //init        PP.setAllowScrolling(true);        container.addClass(WRAPPER);        $('html').addClass(ENABLED);        $htmlBody.css({            'overflow' : 'hidden',            'height' : '100%'        });        responsive();        $(SECTION_SEL).each(function (index) {            var section = $(this);            var slides = section.find(SLIDE_SEL);            var numSlides = slides.length;            $(this).attr('data-index', index);            $(this).css('z-index', movementType.sectionZindex(section) );            //if no active section is defined, the 1st one will be the default one            if (!index && $(SECTION_ACTIVE_SEL).length === 0) {                $(this).addClass(ACTIVE);                initialSection = $(this);            }            movementType.setOriginalPosition('sections', section);            if (typeof options.anchors[index] !== 'undefined') {                $(this).attr('data-anchor', options.anchors[index]);            }            if (typeof options.sectionsColor[index] !== 'undefined') {                $(this).css('background-color', options.sectionsColor[index]);            }            //if there's any slide            if(numSlides > 0){                styleSlides(section, slides, numSlides);            }            else if(options.verticalCentered && !$(this).hasClass('pp-scrollable')){                addTableClass($(this));            }        }).promise().done(function(){            //creating the navigation dots            if (!$.isEmptyObject(options.navigation) ) {                addVerticalNavigation();            }            initialUrl = getInitialUrlAnchors();            //setting the class for the body element            setBodyClass();            $(window).on('load', function() {                scrollToAnchor();            });            $.isFunction( options.afterRender ) && options.afterRender.call( this);        });        /**        * Adds internal classes to be able to provide customizable selectors        * keeping the link with the style sheet.        */        function addInternalSelectors(){            //adding internal class names to void problem with common ones            $(options.sectionSelector).each(function(){                $(this).addClass(SECTION);            });            $(options.slideSelector).each(function(){                $(this).addClass(SLIDE);            });        }        function styleSlides(section, slides, numSlides){            var sliderWidth = numSlides * 100;            var slideWidth = 100 / numSlides;            slides.wrapAll('<div class="' + SLIDES_CONTAINER + '" />');            slides.parent().wrap('<div class="' + SLIDES_WRAPPER + '" />');            if(numSlides > 1){                if(options.controlArrows){                    createSlideArrows(section);                }                if(options.slidesNavigation){                    addSlidesNavigation(section, numSlides);                }            }            slides.each(function(index) {                $(this).data('index', index);                $(this).css('z-index', movementType.slideZindex(section, $(this)) );                //other sections will be overflowing (except the first one, which we will update later on)                movementType.setOriginalPosition('slides', $(this))                if(options.verticalCentered){                    addTableClass($(this));                }            });            var startingSlide = section.find(SLIDE_ACTIVE_SEL);            //if the slide won't be a starting point, the default will be the first one            //the active section isn't the first one? Is not the first slide of the first section? Then we load that section/slide by default.            if( startingSlide.length &&  ($(SECTION_ACTIVE_SEL).index(SECTION_SEL) !== 0 || ($(SECTION_ACTIVE_SEL).index(SECTION_SEL) === 0 && startingSlide.index() !== 0))){                 silentLandscapeScroll(startingSlide, '0%');                 if(section.hasClass(ACTIVE)){                    initialSlide = startingSlide;                 }            }else{                slides.eq(0).addClass(ACTIVE);                silentLandscapeScroll(slides.eq(0), '0%');                if(section.hasClass(ACTIVE)){                    initialSlide = slides.eq(0);                 }            }        }        /**        * Creates the control arrows for the given section        */        function createSlideArrows(section){            section.find(SLIDES_WRAPPER_SEL).after('<div class="' + SLIDES_ARROW_PREV + '"></div><div class="' + SLIDES_ARROW_NEXT + '"></div>');            if(options.controlArrowColor!='#fff'){                section.find(SLIDES_ARROW_NEXT_SEL).css('border-color', 'transparent transparent transparent '+options.controlArrowColor);                section.find(SLIDES_ARROW_PREV_SEL).css('border-color', 'transparent '+ options.controlArrowColor + ' transparent transparent');            }            if(!options.loopHorizontal){                section.find(SLIDES_ARROW_PREV_SEL).hide();            }        }        /**        * Creates a landscape navigation bar with dots for horizontal sliders.        */        function addSlidesNavigation(section, numSlides){            section.append('<div class="' + SLIDES_NAV + '"><ul></ul></div>');            var nav = section.find(SLIDES_NAV_SEL);            //top or bottom            nav.addClass(options.slidesNavPosition);            for(var i=0; i< numSlides; i++){                nav.find('ul').append('<li><a href="#"><span></span></a></li>');            }            //centering it            nav.css('margin-left', '-' + (nav.width()/2) + 'px');            nav.find('li').first().find('a').addClass(ACTIVE);        }        /**        * Enables vertical centering by wrapping the content and the use of table and table-cell        */        function addTableClass(element){            element.addClass('pp-table').wrapInner('<div class="' + TABLE_CELL +'" style="height:100%" />');        }       /**        * Retuns `up` or `down` depending on the scrolling movement to reach its destination        * from the current section.        */        function getYmovement(destiny){            var fromIndex = $(SECTION_ACTIVE_SEL).index(SECTION_SEL);            var toIndex = destiny.index(SECTION_SEL);            if(fromIndex > toIndex){                return 'up';            }            return 'down';        }        /**        * Retuns `right` or `left` depending on the scrolling movement to reach its destination        * from the current slide.        */        function getXmovement(fromIndex, toIndex){            if( fromIndex == toIndex){                return 'none';            }            if(fromIndex > toIndex){                return 'left';            }            return 'right';        }        /**        * Scrolls the page to the given destination        */        function scrollPage(destination, callback) {            var v ={                destination: destination,                callback: callback,                activeSection: $(SECTION_ACTIVE_SEL),                anchorLink: destination.data('anchor'),                sectionIndex: destination.index(SECTION_SEL),                activeSlide: destination.find(SLIDE_ACTIVE_SEL),                toMove: destination,                yMovement: getYmovement(destination),                leavingSection: $(SECTION_ACTIVE_SEL).index(SECTION_SEL) + 1            };            //quiting when activeSection is the target element            if(v.activeSection.is(destination)){ return; }            if(v.activeSlide.length){                var slideAnchorLink = v.activeSlide.data('anchor');                var slideIndex = v.activeSlide.index();            }            v.destination.addClass(ACTIVE).siblings().removeClass(ACTIVE);            v.sectionsToMove = movementType.getSectionsToMove(v);            v = movementType.getScrollingOptions(v);            //callback (onLeave) if the site is not just resizing and readjusting the slides            if($.isFunction(options.onLeave)){                if(options.onLeave.call(v.activeSection, v.leavingSection, (v.sectionIndex + 1), v.yMovement) === false){                    return;                }            }            setState(slideIndex, slideAnchorLink, v.anchorLink, v.sectionIndex);            performMovement(v);            activateMenuAndNav(v.anchorLink, v.sectionIndex)            lastScrolledDestiny = v.anchorLink;            var timeNow = new Date().getTime();            lastAnimation = timeNow;        }        /**        * Performs the movement (by CSS3 or by jQuery)        */        function performMovement(v){            if(options.css3){                movementType.onPerform(v);                v.sectionsToMove.each(function(){                    transformContainer($(this), v.translate3d, options.scrollingSpeed > 0);                });                //even when the scrollingSpeed is 0 there's a little delay, which might cause the                //scrollingSpeed to change in case of using silentMoveTo();                if(options.scrollingSpeed){                    afterSectionLoadsId = setTimeout(function () {                        afterSectionLoads(v);                    }, options.scrollingSpeed);                }else{                    afterSectionLoads(v);                }            }else{                movementType.beforeMoveUp(v);                v.scrollOptions = getScrollProp(v.scrolling);                if(options.scrollingSpeed){                    v.animateSection.animate(                        v.scrollOptions,                    options.scrollingSpeed, options.easing, function () {                        readjustSections(v);                        afterSectionLoads(v);                    });                }else{                    v.animateSection.css(getScrollProp(v.scrolling));                    afterSectionLoadsId = setTimeout(function(){                        readjustSections(v);                        afterSectionLoads(v);                    },400);                }            }        }        /**        * Slides a slider to the given direction.        */        function moveSlide(direction){            var activeSection = $(SECTION_ACTIVE_SEL);            var slides = activeSection.find(SLIDES_WRAPPER_SEL);            var numSlides = slides.find(SLIDE_SEL).length;            // more than one slide needed and nothing should be sliding            if (!slides.length || slideMoving || numSlides < 2) {                return;            }            var currentSlide = slides.find(SLIDE_ACTIVE_SEL);            var destiny = null;            if(direction === 'prev'){                destiny = currentSlide.prev(SLIDE_SEL);            }else{                destiny = currentSlide.next(SLIDE_SEL);            }            //isn't there a next slide in the secuence?            if(!destiny.length){                //respect loopHorizontal settin                if (!options.loopHorizontal) return;                if(direction === 'prev'){                    destiny = currentSlide.siblings(':last');                }else{                    destiny = currentSlide.siblings(':first');                }            }            slideMoving = true;            landscapeScroll(slides, destiny);        }        /**        * Scrolls horizontal sliders.        */        function landscapeScroll(slides, destiny){            var numSlides = slides.find(SLIDE_SEL).length;            var destinyPos = destiny.position();            var slideIndex = destiny.index();            var section = slides.closest(SECTION_SEL);            var sectionIndex = section.index(SECTION_SEL);            var anchorLink = section.data('anchor');            var slidesNav = section.find(SLIDES_NAV_SEL);            var slideAnchor = getSlideAnchor(destiny);            var activeSlide = section.find(SLIDE_ACTIVE_SEL);            var activeSlideIndex = activeSlide.index();            var xMovement = getXmovement(activeSlideIndex, slideIndex);            if(options.onSlideLeave){                //if the site is not just resizing and readjusting the slides                if(xMovement!=='none'){                    if($.isFunction( options.onSlideLeave )){                        if(options.onSlideLeave.call( activeSlide, anchorLink, (sectionIndex + 1), activeSlideIndex, xMovement, slideIndex ) === false){                            slideMoving = false;                            return;                        }                    }                }            }            destiny.addClass(ACTIVE).siblings().removeClass(ACTIVE);            var slidesToMove = movementType.getSlidesToMove(section, activeSlide, activeSlideIndex, destiny, xMovement);            if(!options.loopHorizontal && options.controlArrows){                //hidding it for the fist slide, showing for the rest                section.find(SLIDES_ARROW_PREV_SEL).toggle(slideIndex!==0);                //hidding it for the last slide, showing for the rest                section.find(SLIDES_ARROW_NEXT_SEL).toggle(!destiny.is(':last-child'));            }            //only changing the URL if the slides are in the current section (not for resize re-adjusting)            if(section.hasClass(ACTIVE)){                setState(slideIndex, slideAnchor, anchorLink, sectionIndex);            }            var scrollingOptions = movementType.getHorizontalScrollingOptions(xMovement, destiny, activeSlide);            var translate3d = scrollingOptions.translate3d;            var scrolling = scrollingOptions.scrolling;            var animateSection = scrollingOptions.animateSection;            var afterSlideLoads = function(){                $.isFunction( options.afterSlideLoad ) && options.afterSlideLoad.call( destiny, anchorLink, (sectionIndex + 1), slideAnchor, slideIndex);                movementType.afterSlideLoads(xMovement, slidesToMove, activeSlide, scrolling);                //letting them slide again                slideMoving = false;            };            movementType.beforeMoveRight(xMovement, slidesToMove, activeSlide, scrolling);            if(options.css3){                movementType.onHorizontalPerform(animateSection, translate3d, options.scrollingSpeed > 0);                slidesToMove.each(function(){                    transformContainer($(this), translate3d, options.scrollingSpeed > 0);                });                afterSlideLoadsId = setTimeout(function(){                    afterSlideLoads();                }, options.scrollingSpeed, options.easing);            }else{                movementType.beforeMoveLeft(xMovement, slidesToMove, activeSlide, scrolling);                if(options.scrollingSpeed > 0){                    animateSection.animate({                        left: scrolling                    }, options.scrollingSpeed, options.easing, function(){                        movementType.readjustHorizontalSections(xMovement, slidesToMove, scrolling);                        afterSlideLoads();                    });                }else{                    animateSection.css('left', scrolling);                    setTimeout(function(){                        movementType.readjustHorizontalSections(xMovement, slidesToMove, scrolling);                        afterSlideLoads();                    },400);                }            }            slidesNav.find(ACTIVE_SEL).removeClass(ACTIVE);            slidesNav.find('li').eq(slideIndex).find('a').addClass(ACTIVE);        }        //when resizing the site, we adjust the heights of the sections, slimScroll...        $window.resize(resizeHandler);        function resizeHandler(){            //checking if it needs to get responsive            responsive();            //in order to call the functions only when the resize is finished            //http://stackoverflow.com/questions/4298612/jquery-how-to-call-resize-event-only-once-its-finished-resizing            clearTimeout(resizeId);            resizeId = setTimeout(function(){                $.isFunction( options.afterResize ) && options.afterResize.call(container);            }, 350);        }        /**        * Checks if the site needs to get responsive and disables autoScrolling if so.        * A class `pp-responsive` is added to the plugin's container in case the user wants to use it for his own responsive CSS.        */        function responsive(){            var widthLimit = options.responsive || options.responsiveWidth; //backwards compatiblity            var heightLimit = options.responsiveHeight;            if(widthLimit){                PP.setResponsive($window.width() < widthLimit);            }            if(heightLimit){                var isResponsive = container.hasClass(RESPONSIVE);                //if its not already in responsive mode because of the `width` limit                if(!isResponsive){                    PP.setResponsive($window.height() < heightLimit);                }            }        }        /**        * Adds transition animations for the given element        */        function addAnimation(element){            var transition = 'all ' + options.scrollingSpeed + 'ms ' + options.easingcss3;            element.removeClass(NO_TRANSITION);            return element.css({                '-webkit-transition': transition,                'transition': transition            });        }        /**        * Remove transition animations for the given element        */        function removeAnimation(element){            return element.addClass(NO_TRANSITION);        }        /**        * Sets the state of the website depending on the active section/slide.        * It changes the URL hash when needed and updates the body class.        */        function setState(slideIndex, slideAnchor, anchorLink, sectionIndex){            var sectionHash = '';            if(options.anchors.length && !options.lockAnchors){                //isn't it the first slide?                if(slideIndex){                    if(typeof anchorLink !== 'undefined'){                        sectionHash = anchorLink;                    }                    //slide without anchor link? We take the index instead.                    if(typeof slideAnchor === 'undefined'){                        slideAnchor = slideIndex;                    }                    lastScrolledSlide = slideAnchor;                    setUrlHash(sectionHash + '/' + slideAnchor);                //first slide won't have slide anchor, just the section one                }else if(typeof slideIndex !== 'undefined'){                    lastScrolledSlide = slideAnchor;                    setUrlHash(anchorLink);                }                //section without slides                else{                    setUrlHash(anchorLink);                }            }            setBodyClass();        }        /**        * Gets the anchor for the given slide. Its index will be used if there's none.        */        function getSlideAnchor(slide){            var slideAnchor = slide.data('anchor');            var slideIndex = slide.index();            //Slide without anchor link? We take the index instead.            if(typeof slideAnchor === 'undefined'){                slideAnchor = slideIndex;            }            return slideAnchor;        }       /**        * Gets the anchor for the given slide. Its index will be used if there's none.        */        function getSectionAnchor(section){            var sectionAnchor = section.data('anchor');            var sectionIndex = section.index();            //Slide without anchor link? We take the index instead.            if(typeof sectionAnchor === 'undefined'){                sectionAnchor = sectionIndex;            }            return sectionAnchor;        }        /**        * Actions to execute after a secion is loaded        */        function afterSectionLoads(v){            //moving the sections in between to the right position            if(!options.css3 && v.yMovement == 'down'){                v.sectionsToMove.each(function(index){                    if(index != v.destination.index(SECTION_SEL)){                        $(this).css(getScrollProp(v.scrolling));                    }                });            }            //callback (afterLoad) if the site is not just resizing and readjusting the slides            $.isFunction(options.afterLoad) && options.afterLoad.call(this, v.anchorLink, (v.sectionIndex + 1));            $.isFunction(v.callback) && v.callback.call(this);        }        function getSectionsToMove(v){            var sectionToMove;            var activeSectionIndex = v.activeSection.index(SECTION_SEL);            if(v.yMovement === 'down'){                sectionToMove = $(SECTION_SEL).map(function(index){                    if (index <= v.destination.index(SECTION_SEL) && index > activeSectionIndex){                        return $(this);                    }                });            }else{                sectionToMove = $(SECTION_SEL).map(function(index){                    if (index > v.destination.index(SECTION_SEL) && index <= activeSectionIndex){                        return $(this);                    }                });            }            return sectionToMove;        }        function getSlidesToMove(section, activeSlide, activeSlideIndex, destination, xMovement){            var slidesToMove;            if(xMovement === 'right'){                 slidesToMove = section.find(SLIDE_SEL).map(function(index){                    if (index <= destination.index() && index > activeSlideIndex){                        return $(this);                    }                });            }else{                slidesToMove = section.find(SLIDE_SEL).map(function(index){                    if (index > destination.index() && index <= activeSlideIndex){                        return $(this);                    }                });            }            return slidesToMove;        }        /**        * Returns the sections to re-adjust in the background after the section loads.        */        function readjustSections(v){            if(v.yMovement === 'up'){                v.sectionsToMove.each(function(index){                    $(this).css(getScrollProp(v.scrolling));                });            }        }        /**        * Gets the property used to create the scrolling effect when using jQuery animations        * depending on the plugin direction option.        */        function getScrollProp(propertyValue){            if(options.direction === 'vertical'){                return {'top': propertyValue};            }            return {'left': propertyValue};        }        /**        * Scrolls silently (with no animation) the page to the given Y position.        */        function silentScroll(section, top){            if (options.css3) {                var translate3d = 'translate3d(0, ' + top + ', 0)';                transformContainer(section, translate3d, false);            }            else {                section.css('top', top);            }        }        /**        * Scrolls silently (with no animation) the page to the given Y position.        */        function silentLandscapeScroll(slide, left){            if (options.css3) {                var translate3d = 'translate3d(' + left + ', 0, 0)';                transformContainer(slide, translate3d, false);            }            else {                slide.css('left', left);            }        }        /**        * Sets the URL hash.        */        function setUrlHash(url){            if(options.recordHistory){                if(!isLandingPage || url != initialUrl){                    location.hash = url;                }            }else{                //Mobile Chrome doesn't work the normal way, so... lets use HTML5 for phones :)                if(isTouch){                    history.replaceState(undefined, undefined, '#' + url);                }else{                    var baseUrl = window.location.href.split('#')[0];                    window.location.replace( baseUrl + '#' + url );                }            }        }        function getInitialUrlAnchors(){            var sectionAnchor = getSectionAnchor(initialSection);            var url;            //is not the 1st slide in the section?            if(initialSlide.index()){                var slideAnchor = getSlideAnchor(initialSlide);                url = sectionAnchor + '/' + slideAnchor;            }            //initial slide won't display the anchor in the URL.            else{                url = sectionAnchor;            }            return url;        }        /**        * Sets a class for the body of the page depending on the active section / slide        */        function setBodyClass(){            var section = $(SECTION_ACTIVE_SEL);            var slide = section.find(SLIDE_ACTIVE_SEL);            var sectionAnchor = getSectionAnchor(section);            var slideAnchor = getSlideAnchor(slide);            var text = String(sectionAnchor);            if (slide.length) {                text = text + '-' + slideAnchor;            }            //changing slash for dash to make it a valid CSS style            text = text.replace('/', '-').replace('#','');            //removing previous anchor classes            var classRe = new RegExp('\\b\\s?' + VIEWING_PREFIX + '-[^\\s]+\\b', "g");            $body[0].className = $body[0].className.replace(classRe, '');            //adding the current anchor            $body.addClass(VIEWING_PREFIX + '-' + text);        }        /**        * Scrolls to the anchor in the URL when loading the site        */        function scrollToAnchor(){            //getting the anchor link in the URL and deleting the `#`            var value =  window.location.hash.replace('#', '').split('/');            var section = value[0];            var slide = value[1];            if(section){  //if theres any #                if(options.animateAnchor){                    scrollPageAndSlide(section, slide);                }                else{                    PP.silentMoveTo(section, slide);                }            }        }        /**        * Scrolls to the given section and slide anchors        */        function scrollPageAndSlide(section, slide){            var section = getSectionByAnchor(section);            //default slide            if (typeof slide === 'undefined') {                slide = 0;            }            //we need to scroll to the section and then to the slide            if (section !== lastScrolledDestiny && !section.hasClass(ACTIVE)){                scrollPage(section, function(){                    scrollSlider(section, slide);                });            }            //if we were already in the section            else{                scrollSlider(section, slide);            }        }        /**        * Scrolls the slider to the given slide destination for the given section        */        function scrollSlider(section, slideAnchor){            if(typeof slideAnchor !== 'undefined'){                var slides = section.find(SLIDES_WRAPPER_SEL);                var destiny =  getSlideByAnchor(slideAnchor, section);                if(destiny.length){                    landscapeScroll(slides, destiny);                }            }        }        /**        * Gets a section by its anchor / index        */        function getSectionByAnchor(sectionAnchor){            //section            var section = $(SECTION_SEL + '[data-anchor="'+sectionAnchor+'"]');            if(!section.length){                section = $(SECTION_SEL).eq( (sectionAnchor -1) );            }            return section;        }        /**        * Gets a slide inside a given section by its anchor / index        */        function getSlideByAnchor(slideAnchor, section){            var slides = section.find(SLIDES_WRAPPER_SEL);            var slide =  slides.find(SLIDE_SEL + '[data-anchor="'+slideAnchor+'"]');            if(!slide.length){                slide = slides.find(SLIDE_SEL).eq(slideAnchor);            }            return slide;        }        /**        * Determines if the transitions between sections still taking place.        * The variable `scrollDelay` adds a "save zone" for devices such as Apple laptops and Apple magic mouses        */        function isMoving(){            var timeNow = new Date().getTime();            // Cancel scroll if currently animating or within quiet period            if (timeNow - lastAnimation < scrollDelay + options.scrollingSpeed) {                return true;            }            return false;        }        //detecting any change on the URL to scroll to the given anchor link        //(a way to detect back history button as we play with the hashes on the URL)        $(window).on('hashchange', hashChangeHandler);        /**        * Actions to do when the hash (#) in the URL changes.        */        function hashChangeHandler(){            if(!isScrolling && !options.lockAnchors){                var value =  window.location.hash.replace('#', '').split('/');                var section = value[0];                var slide = value[1];                //when moving to a slide in the first section for the first time (first time to add an anchor to the URL)                var isFirstSlideMove =  (typeof lastScrolledDestiny === 'undefined');                var isFirstScrollMove = (typeof lastScrolledDestiny === 'undefined' && typeof slide === 'undefined' && !slideMoving);                if(section.length){                    /*in order to call scrollpage() only once for each destination at a time                    It is called twice for each scroll otherwise, as in case of using anchorlinks `hashChange`                    event is fired on every scroll too.*/                    if ((section && section !== lastScrolledDestiny) && !isFirstSlideMove || isFirstScrollMove || (!slideMoving && lastScrolledSlide != slide ))  {                        scrollPageAndSlide(section, slide);                    }                }                //                else{                    section = getSectionAnchor(initialSection);                    if (isFirstScrollMove){                        slide = initialSection.find(SLIDE_ACTIVE_SEL);                    }else{                        slide = getSlideAnchor( initialSlide);                    }                    isLandingPage = true;                    scrollPageAndSlide(section, slide);                }            }        }        /**        * Cross browser transformations        */        function getTransforms(translate3d) {            return {                '-webkit-transform': translate3d,                    '-moz-transform': translate3d,                    '-ms-transform': translate3d,                    'transform': translate3d            };        }        /**         * Adds a css3 transform property to the container class with or without animation depending on the animated param.         */        function transformContainer(element, translate3d, animated) {            if(animated){                addAnimation(element);            }else{                removeAnimation(element);            }            element.css(getTransforms(translate3d));            //syncronously removing the class after the animation has been applied.            setTimeout(function(){                element.removeClass(NO_TRANSITION);            },10);        }        /**         * Sliding with arrow keys, both, vertical and horizontal         */        $(document).keydown(keydownHandler);        function keydownHandler(e){            var activeElement = $(':focus');            if(!activeElement.is('textarea') && !activeElement.is('input') && !activeElement.is('select') &&                options.keyboardScrolling){                var keyCode = e.which;                //preventing the scroll with arrow keys & spacebar & Page Up & Down keys                var keyControls = [40, 38, 32, 33, 34];                if($.inArray(keyCode, keyControls) > -1){                    e.preventDefault();                }                onkeydown(e);            }        }        /**        * Keydown event        */        function onkeydown(e){             var shiftPressed = e.shiftKey;            //Moving the main page with the keyboard arrows if keyboard scrolling is enabled            switch (e.which) {                //up                case 38:                case 33:                    PP.moveSectionUp();                    break;                //down                case 32: //spacebar                    if(shiftPressed){                        PP.moveSectionUp();                        break;                    }                case 40:                case 34:                    PP.moveSectionDown();                    break;                //Home                case 36:                    PP.moveTo(1);                    break;                //End                case 35:                    PP.moveTo($(SECTION_SEL).length);                    break;                //left                case 37:                    if(options.direction == 'horizontal'){                        PP.moveSectionUp();                    }else{                        PP.moveSlideLeft();                    }                    break;                //right                case 39:                    if(options.direction == 'horizontal'){                        PP.moveSectionDown();                    }else{                        PP.moveSlideRight();                    }                    break;                default:                    return; // exit this handler for other keys            }        }        /**        * If `normalScrollElements` is used, the mouse wheel scrolling will scroll normally        * over the defined elements in the option.        */        if(options.normalScrollElements){            $(document).on('mouseenter', options.normalScrollElements, function () {                PP.setMouseWheelScrolling(false);            });            $(document).on('mouseleave', options.normalScrollElements, function(){                PP.setMouseWheelScrolling(true);            });        }        /**         * Detecting mousewheel scrolling         *         * http://blogs.sitepointstatic.com/examples/tech/mouse-wheel/index.html         * http://www.sitepoint.com/html5-javascript-mouse-wheel/         */        function MouseWheelHandler(e) {            if(!isMoving() && options.autoScrolling){                // cross-browser wheel delta                e = window.event || e;                var delta = Math.max(-1, Math.min(1,                        (e.wheelDelta || -e.deltaY || -e.detail)));                var activeSection = $(SECTION_ACTIVE_SEL);                var scrollable = isScrollable(activeSection);                //scrolling down?                if (delta < 0) {                    scrolling('down', scrollable);                //scrolling up?                }else {                    scrolling('up', scrollable);                }                return false;            }            if(options.fitToSection){                //stopping the auto scroll to adjust to a section                $htmlBody.stop();            }         }        var isScrolling = false;        //when scrolling...        $window.on('scroll', scrollHandler);        function scrollHandler(){            var currentSection;            if(!options.autoScrolling){                var currentScroll = $window.scrollTop();                var visibleSectionIndex = 0;                var initial = Math.abs(currentScroll - document.querySelectorAll(SECTION_SEL)[0].offsetTop);                //taking the section which is showing more content in the viewport                var sections =  document.querySelectorAll(SECTION_SEL);                for (var i = 0; i < sections.length; ++i) {                    var section = sections[i];                    var current = Math.abs(currentScroll - section.offsetTop);                    if(current < initial){                        visibleSectionIndex = i;                        initial = current;                    }                }                //geting the last one, the current one on the screen                currentSection = $(sections).eq(visibleSectionIndex);                //executing only once the first time we reach the section                if(!currentSection.hasClass(ACTIVE)){                    isScrolling = true;                    var leavingSection = $(SECTION_ACTIVE_SEL);                    var leavingSectionIndex = leavingSection.index(SECTION_SEL) + 1;                    var yMovement = getYmovement(currentSection);                    var anchorLink  = currentSection.data('anchor');                    var sectionIndex = currentSection.index(SECTION_SEL) + 1;                    var activeSlide = currentSection.find(SLIDE_ACTIVE_SEL);                     if(activeSlide.length){                        var slideAnchorLink = activeSlide.data('anchor');                        var slideIndex = activeSlide.index();                    }                     if(!isMoving()){                        currentSection.addClass(ACTIVE).siblings().removeClass(ACTIVE);                        $.isFunction( options.onLeave ) && options.onLeave.call( leavingSection, leavingSectionIndex, sectionIndex, yMovement);                        $.isFunction( options.afterLoad ) && options.afterLoad.call( currentSection, anchorLink, sectionIndex);                        activateMenuAndNav(anchorLink, sectionIndex - 1);                        if(options.anchors.length){                            //needed to enter in hashChange event when using the menu with anchor links                            lastScrolledDestiny = anchorLink;                            setState(slideIndex, slideAnchorLink, anchorLink, sectionIndex);                        }                    }                    //small timeout in order to avoid entering in hashChange event when scrolling is not finished yet                    clearTimeout(scrollId);                    scrollId = setTimeout(function(){                        isScrolling = false;                    }, 100);                }                if(options.fitToSection){                    //for the auto adjust of the viewport to fit a whole section                    clearTimeout(scrollId2);                    scrollId2 = setTimeout(function(){                        //checking fitToSection again in case it was set to false before the timeout delay                        if(!isMoving() && options.fitToSection){                              $htmlBody.animate({                                scrollTop: currentSection.position().top                            });                        }                    }, options.fitToSectionDelay);                }            }        }        /**        * Determines the way of scrolling up or down:        * by 'automatically' scrolling a section or by using the default and normal scrolling.        */        function scrolling(type, scrollable){            var check;            var scrollSection;            if(type == 'down'){                check = 'bottom';                scrollSection = PP.moveSectionDown;            }else{                check = 'top';                scrollSection = PP.moveSectionUp;            }            if(scrollable.length > 0 ){                //is the scrollbar at the start/end of the scroll?                if(isScrolled(check, scrollable)){                    scrollSection();                }else{                    return true;                }            }else{                // moved up/down                scrollSection();            }        }        /**        * Return a boolean depending on whether the scrollable element is at the end or at the start of the scrolling        * depending on the given type.        */        function isScrolled(type, scrollable){            if(type === 'top'){                return !scrollable.scrollTop();            }else if(type === 'bottom'){                return scrollable.scrollTop() + 1 + scrollable.innerHeight() >= scrollable[0].scrollHeight;            }        }         /**        * Determines whether the active section or slide is scrollable through and scrolling bar        */        function isScrollable(activeSection){            return activeSection.filter('.pp-scrollable');        }        /**        * Removes the auto scrolling action fired by the mouse wheel and tackpad.        * After this function is called, the mousewheel and trackpad movements won't scroll through sections.        */        function removeMouseWheelHandler(){            if (container.get(0).addEventListener) {                container.get(0).removeEventListener('mousewheel', MouseWheelHandler, false); //IE9, Chrome, Safari, Oper                container.get(0).removeEventListener('wheel', MouseWheelHandler, false); //Firefox            } else {                container.get(0).detachEvent('onmousewheel', MouseWheelHandler); //IE 6/7/8            }        }        /**        * Adds the auto scrolling action for the mouse wheel and tackpad.        * After this function is called, the mousewheel and trackpad movements will scroll through sections        */        function addMouseWheelHandler(){            if (container.get(0).addEventListener) {                container.get(0).addEventListener('mousewheel', MouseWheelHandler, false); //IE9, Chrome, Safari, Oper                container.get(0).addEventListener('wheel', MouseWheelHandler, false); //Firefox            } else {                container.get(0).attachEvent('onmousewheel', MouseWheelHandler); //IE 6/7/8            }        }        /**        * Adds the possibility to auto scroll through sections on touch devices.        */        function addTouchHandler(){            if(isTouch){                //Microsoft pointers                var MSPointer = getMSPointer();                container.off('touchstart ' +  MSPointer.down).on('touchstart ' + MSPointer.down, touchStartHandler);                container.off('touchmove ' + MSPointer.move).on('touchmove ' + MSPointer.move, touchMoveHandler);            }        }        /**        * Removes the auto scrolling for touch devices.        */        function removeTouchHandler(){            if(isTouch){                //Microsoft pointers                var MSPointer = getMSPointer();                container.off('touchstart ' + MSPointer.down);                container.off('touchmove ' + MSPointer.move);            }        }        /*        * Returns and object with Microsoft pointers (for IE<11 and for IE >= 11)        * http://msdn.microsoft.com/en-us/library/ie/dn304886(v=vs.85).aspx        */        function getMSPointer(){            var pointer;            //IE >= 11 & rest of browsers            if(window.PointerEvent){                pointer = { down: 'pointerdown', move: 'pointermove', up: 'pointerup'};            }            //IE < 11            else{                pointer = { down: 'MSPointerDown', move: 'MSPointerMove', up: 'MSPointerUp'};            }            return pointer;        }        /**        * Gets the pageX and pageY properties depending on the browser.        * https://github.com/alvarotrigo/fullPage.js/issues/194#issuecomment-34069854        */        function getEventsPage(e){            var events = new Array();            events.y = (typeof e.pageY !== 'undefined' && (e.pageY || e.pageX) ? e.pageY : e.touches[0].pageY);            events.x = (typeof e.pageX !== 'undefined' && (e.pageY || e.pageX) ? e.pageX : e.touches[0].pageX);            return events;        }        /**        * As IE >= 10 fires both touch and mouse events when using a mouse in a touchscreen        * this way we make sure that is really a touch event what IE is detecting.        */        function isReallyTouch(e){            //if is not IE   ||  IE is detecting `touch` or `pen`            return typeof e.pointerType === 'undefined' || e.pointerType != 'mouse';        }        /**        * Getting the starting possitions of the touch event        */        function touchStartHandler(event){            var e = event.originalEvent;            if(isReallyTouch(e)){                var touchEvents = getEventsPage(e);                touchStartY = touchEvents.y;                touchStartX = touchEvents.x;            }        }        /* Detecting touch events        */        function touchMoveHandler(event){            var e = event.originalEvent;            // additional: if one of the normalScrollElements isn't within options.normalScrollElementTouchThreshold hops up the DOM chain            if ( !checkParentForNormalScrollElement(event.target) && isReallyTouch(e) ) {                var activeSection = $(SECTION_ACTIVE_SEL);                var scrollable = isScrollable(activeSection);                if(!scrollable.length){                    event.preventDefault();                }                if (!isMoving()) {                    var touchEvents = getEventsPage(e);                    touchEndY = touchEvents.y;                    touchEndX = touchEvents.x;                    var isHorizontalScroll = Math.abs(touchStartX - touchEndX) > (Math.abs(touchStartY - touchEndY));                    //X movement bigger than Y movement?                    if (isHorizontalScroll) {                        //is the movement greater than the minimum resistance to scroll?                        if (Math.abs(touchStartX - touchEndX) > ($(window).width() / 100 * options.touchSensitivity)) {                            if (touchStartX > touchEndX) {                                PP.moveSlideRight();                            } else if (touchEndX > touchStartX) {                                PP.moveSlideLeft();                            }                        }                    } else if (Math.abs(touchStartY - touchEndY) > ($(window).height() / 100 * options.touchSensitivity)) {                        if (touchStartY > touchEndY) {                            scrolling('down', scrollable);                        } else if (touchEndY > touchStartY) {                            scrolling('up', scrollable);                        }                    }                }            }        }        /**         * recursive function to loop up the parent nodes to check if one of them exists in options.normalScrollElements         * Currently works well for iOS - Android might need some testing         * @param  {Element} el  target element / jquery selector (in subsequent nodes)         * @param  {int}     hop current hop compared to options.normalScrollElementTouchThreshold         * @return {boolean} true if there is a match to options.normalScrollElements         */        function checkParentForNormalScrollElement (el, hop) {            hop = hop || 0;            var parent = $(el).parent();            if (hop < options.normalScrollElementTouchThreshold &&                parent.is(options.normalScrollElements) ) {                return true;            } else if (hop == options.normalScrollElementTouchThreshold) {                return false;            } else {                return checkParentForNormalScrollElement(parent, ++hop);            }        }        /**        * Creates a vertical navigation bar.        */        function addVerticalNavigation(){            $body.append('<div id="' + SECTION_NAV + '"><ul></ul></div>');            var nav = $(SECTION_NAV_SEL);            nav.addClass(options.navigation.position);            for (var i = 0; i < $(SECTION_SEL).length; i++) {                var link = '';                if (options.anchors.length) {                    link = options.anchors[i];                }                var li = '<li><a href="#' + link + '"><span></span></a>';                // Only add tooltip if needed (defined by user)                var tooltip = options.navigation.tooltips[i];                if (typeof tooltip !== 'undefined' && tooltip !== '') {                    li += '<div class="' + SECTION_NAV_TOOLTIP + ' ' + options.navigation.position + '">' + tooltip + '</div>';                }                li += '</li>';                nav.find('ul').append(li);            }            nav.find(SECTION_NAV_TOOLTIP_SEL).css('color', options.navigation.textColor);            //centering it vertically            $(SECTION_NAV_SEL).css('margin-top', '-' + ($(SECTION_NAV_SEL).height()/2) + 'px');            //activating the current active section            $(SECTION_NAV_SEL).find('li').eq($(SECTION_ACTIVE_SEL).index(SECTION_SEL)).find('a').addClass(ACTIVE);            nav.find('span').css('border-color', options.navigation.bulletsColor);        }        /**        * Scrolls to the section when clicking the navigation bullet        */        $(document).on('click touchstart', '#pp-nav a', function(e){            e.preventDefault();            var index = $(this).parent().index();            scrollPage($(SECTION_SEL).eq(index));        });        /**        * Scrolls the slider to the given slide destination for the given section        */        $document.on('click touchstart', SLIDES_NAV_LINK_SEL, function(e){            e.preventDefault();            var slides = $(this).closest(SECTION_SEL).find(SLIDES_WRAPPER_SEL);            var destiny = slides.find(SLIDE_SEL).eq($(this).closest('li').index());            landscapeScroll(slides, destiny);        });        /**         * Scrolling horizontally when clicking on the slider controls.         */        $(SECTION_SEL).on('click touchstart', SLIDES_ARROW_SEL, function() {            if ($(this).hasClass(SLIDES_PREV)) {                PP.moveSlideLeft();            } else {                PP.moveSlideRight();            }        });         /**         * Activating the website navigation dots according to the given slide name.         */        function activateNavDots(name, sectionIndex){            if(options.navigation){                $('#pp-nav').find('.active').removeClass('active');                if(name){                    $('#pp-nav').find('a[href="#' + name + '"]').addClass('active');                }else{                    $('#pp-nav').find('li').eq(sectionIndex).find('a').addClass('active');                }            }        }        /**         * Activating the website main menu elements according to the given slide name.         */        function activateMenuElement(name){            if(options.menu){                $(options.menu).find('.active').removeClass('active');                $(options.menu).find('[data-menuanchor="'+name+'"]').addClass('active');            }        }        function activateMenuAndNav(anchor, index){            activateMenuElement(anchor);            activateNavDots(anchor, index);        }        /**        * Checks for translate3d support        * @return boolean        * http://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support        */        function support3d() {            var el = document.createElement('p'),                has3d,                transforms = {                    'webkitTransform':'-webkit-transform',                    'OTransform':'-o-transform',                    'msTransform':'-ms-transform',                    'MozTransform':'-moz-transform',                    'transform':'transform'                };            // Add it to the body to get the computed style.            document.body.insertBefore(el, null);            for (var t in transforms) {                if (el.style[t] !== undefined) {                    el.style[t] = 'translate3d(1px,1px,1px)';                    has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);                }            }            document.body.removeChild(el);            return (has3d !== undefined && has3d.length > 0 && has3d !== 'none');        }         /*        * Destroys fullpage.js plugin events and optinally its html markup and styles        */        PP.destroy = function(all){            PP.setMouseWheelScrolling(false);            PP.setKeyboardScrolling(false);            container.addClass(DESTROYED);            clearTimeout(resizeId);            clearTimeout(afterSlideLoadsId);            clearTimeout(afterSectionLoadsId);            $(window)                .off('hashchange', hashChangeHandler)                .off('scroll', scrollHandler)                .off('resize', resizeHandler);            $(document)                .off('click', SECTION_NAV_SEL + ' a')                .off('mouseenter', SECTION_NAV_SEL + ' li')                .off('mouseleave', SECTION_NAV_SEL + ' li')                .off('click', SLIDES_NAV_LINK_SEL)                .off('mouseover', options.normalScrollElements)                .off('mouseout', options.normalScrollElements);            //lets make a mess!            if(all){                destroyStructure();            }        };        /*        * Removes inline styles added by pagePiling.js        */        function destroyStructure(){            $(SECTION_NAV_SEL + ', ' + SLIDES_NAV_SEL +  ', ' + SLIDES_ARROW_SEL).remove();            //removing inline styles            $(SECTION_SEL).css({                'height': '',                'background-color' : '',                'padding': '',                'z-index': 'auto'            });            container.css({                'height': '',                'position': '',                '-ms-touch-action': '',                'touch-action': '',                'overflow': ''            });            //removing added classes            $(SECTION_SEL + ", " + SLIDE_SEL).each(function(){                $(this).removeData('index').removeAttr('style')                        .removeData('index').removeAttr('data-index')                        .removeData('anchor').removeAttr('data-anchor')            });            if(options.menu){                $(options.menu).find('[data-menuanchor]').removeClass('active');                $(options.menu).find('[data-menuanchor]').removeData('menuanchor');            }            $htmlBody.css({                'overflow': '',                'height': ''            });            // remove .pp-enabled class            $('html').removeClass(ENABLED);            // remove all of the .pp-viewing- classes            $.each($body.get(0).className.split(/\s+/), function (index, className) {                if (className.indexOf(VIEWING_PREFIX) === 0) {                    $body.removeClass(className);                }            });            //removing added classes            $(SECTION_SEL + ', ' + SLIDE_SEL).each(function(){                $(this).removeClass(TABLE + ' ' + ACTIVE);            });            //Unwrapping content            container.find(TABLE_CELL_SEL + ', ' + SLIDES_CONTAINER_SEL + ', ' + SLIDES_WRAPPER_SEL).each(function(){                //unwrap not being use in case there's no child element inside and its just text                $(this).replaceWith(this.childNodes);            });            //scrolling the page to the top with no animation            $htmlBody.scrollTop(0);        }        /*        * Sets the state for a variable with multiple states (original, and temporal)        * Some variables such as `autoScrolling` or `recordHistory` might change automatically its state when using `responsive` or `autoScrolling:false`.        * This function is used to keep track of both states, the original and the temporal one.        * If type is not 'internal', then we assume the user is globally changing the variable.        */        function setVariableState(variable, value, type){            options[variable] = value;            if(type !== 'internal'){                originals[variable] = value;            }        }        /**        * Normal pagepipiling        */        function normalMovement(){            var self = this;            self.setOriginalPosition = function(type, element){                if(type == 'slides'){                    //other sections will be overflowing (except the first one, which we will update later on)                    silentLandscapeScroll(element, '0%');                }            };            self.sectionZindex = function(section){                var sectionIndex = section.index(SECTION_SEL);                var zIndex = $(SECTION_SEL).length - sectionIndex;                return zIndex;            };            self.slideZindex = function(section, slide){                var slideIndex = slide.index();                var zIndex = section.find(SLIDE_SEL).length - slideIndex;                return zIndex;            };            self.getScrollingOptions = function(v){                //scrolling down (moving sections up making them disappear)                if (v.yMovement === 'down') {                    v.translate3d = self.getTranslate3d();                    v.scrolling = '-100%';                    if(!options.css3){                        self.beforeMoveDown(v);                    }                    v.animateSection = v.activeSection;                }                //scrolling up (moving section down to the viewport)                else {                    v.translate3d = 'translate3d(0px, 0px, 0px)';                    v.scrolling = '0';                    v.animateSection = v.destination;                }                return v;            };            self.beforeMoveDown = function(v){                 v.sectionsToMove.each(function(index){                     if(index != v.activeSection.index(SECTION_SEL)){                         $(this).css(getScrollProp(v.scrolling));                     }                 });            };            self.onPerform = function(v){                transformContainer(v.animateSection, v.translate3d, options.scrollingSpeed > 0);            };            self.beforeMoveUp = function(v){                //nothing            };            self.afterSectionLoads = function(v){                //nothing            };            self.getSectionsToMove = function(v){                var sectionToMove;                if(v.yMovement === 'down'){                    sectionToMove = $(SECTION_SEL).map(function(index){                        if (index < v.destination.index(SECTION_SEL)){                            return $(this);                        }                    });                }else{                    sectionToMove = $(SECTION_SEL).map(function(index){                        if (index > v.destination.index(SECTION_SEL)){                            return $(this);                        }                    });                }                return sectionToMove;            };            self.getSlidesToMove = function(activeSection, activeSlide, activeSlideIndex, destination, xMovement){                var slidesToMove;                if(xMovement === 'right'){                    slidesToMove = activeSection.find(SLIDE_SEL).map(function(index){                        if (index < destination.index()){                            return $(this);                        }                    });                }else{                    slidesToMove = activeSection.find(SLIDE_SEL).map(function(index){                        if (index > destination.index()){                            return $(this);                        }                    });                }                return slidesToMove;            };            self.getTranslate3d = function(){                 if (options.direction !== 'vertical') {                  return 'translate3d(-100%, 0px, 0px)';                }                return 'translate3d(0px, -100%, 0px)';            };            self.getHorizontalScrollingOptions = function(xMovement, destiny, activeSlide){                var options = {}                //scrolling down (moving sections up making them disappear)                if (xMovement === 'right') {                    var options = {                        translate3d: 'translate3d(-100%, 0px, 0px)',                        scrolling: '-100%',                        animateSection: activeSlide                    };                }                //scrolling up (moving section down to the viewport)                else {                    var options = {                        translate3d: 'translate3d(0px, 0px, 0px)',                        scrolling: '0%',                        animateSection: destiny                    };                }                return options;            };             self.afterSlideLoads = function(xMovement, slidesToMove, activeSlide){                //nothing            };            self.beforeMoveLeft = function(xMovement, slidesToMove, activeSlide, scrolling){                //nothing            };            self.beforeMoveRight = function(xMovement, slidesToMove, activeSlide, scrolling){                if (!options.css3 && xMovement === 'right'){                     slidesToMove.each(function(index){                        if(index != activeSlide.data('index')){                            $(this).css('left', scrolling);                        }                    });                }            }            self.onHorizontalPerform = function(animateSection, translate3d, animated){                transformContainer(animateSection, translate3d, animated);            };            self.readjustHorizontalSections = function(xMovement, slidesToMove, scrolling){                if(xMovement === 'left'){                    slidesToMove.each(function(index){                        $(this).css('left', scrolling);                    });                }            };            //retrieve the top layer section when all layers are piled            self.getTopLayer = function(){                return $(SECTION_SEL).first();            };        }        /**        * Inverted pagepipiling        */        function invertedMovement() {            var self = this;            self.setOriginalPosition = function (type, element) {                if (type == 'sections') {                    //other sections will be overflowing (except the first one, which we will update later on)                    if(!element.hasClass(ACTIVE)){                        silentScroll(element, '100%');                    }                }else{                    silentLandscapeScroll(element, '100%');                }            };            self.sectionZindex = function (section) {                var sectionIndex = section.index(SECTION_SEL);                var zIndex = sectionIndex + 1;                return zIndex;            };            self.slideZindex = function (section, slide) {                var slideIndex = slide.index();                var zIndex = slideIndex + 1;                return zIndex;            };            self.getScrollingOptions = function (v) {                //scrolling down (moving sections up making them disappear)                if (v.yMovement === 'down') {                    v.translate3d = 'translate3d(0px, 0px, 0px)';                    v.scrolling = '0%';                    v.animateSection = v.destination;                }                //scrolling up (moving section down to the viewport)                else {                    v.translate3d = self.getTranslate3d();                    v.scrolling = '100%';                    v.animateSection = v.activeSection;                }                return v;            };            self.beforeMoveUp = function (v) {                if(v.yMovement == 'up'){                    v.sectionsToMove.each(function(index){                        if($(this).data('index') != v.activeSection.data('index')){                            $(this).css(getScrollProp(v.scrolling));                        }                    });                }            };            self.onPerform = function(v){                //nothing            };            self.afterSectionLoads = function (v) {                //moving the sections in between to the right position                if(!options.css3 && v.yMovement == 'down'){                    v.sectionsToMove.each(function(index){                        if(index != v.destination.index(SECTION_SEL)){                            $(this).css(getScrollProp(v.scrolling));                        }                    });                }            };            self.getSectionsToMove = function(v){                var sectionToMove;                var activeSectionIndex = v.activeSection.index(SECTION_SEL);                if(v.yMovement === 'down'){                    sectionToMove = $(SECTION_SEL).map(function(index){                        if (index <= v.destination.index(SECTION_SEL) && index > activeSectionIndex){                            return $(this);                        }                    });                }else{                    sectionToMove = $(SECTION_SEL).map(function(index){                        if (index > v.destination.index(SECTION_SEL) && index <= activeSectionIndex){                            return $(this);                        }                    });                }                return sectionToMove;            };            self.getSlidesToMove = function(activeSection, activeSlide, activeSlideIndex, destination, xMovement){                var slidesToMove;                if(xMovement === 'right'){                     slidesToMove = activeSection.find(SLIDE_SEL).map(function(index){                        if (index <= destination.index() && index > activeSlideIndex){                            return $(this);                        }                    });                }else{                    slidesToMove = activeSection.find(SLIDE_SEL).map(function(index){                        if (index > destination.index() && index <= activeSlideIndex){                            return $(this);                        }                    });                }                return slidesToMove;            };            self.getTranslate3d = function(){                 if (options.direction !== 'vertical') {                  return 'translate3d(100%, 0px, 0px)';                }                return 'translate3d(0px, 100%, 0px)';            };            self.getHorizontalScrollingOptions = function(xMovement, destiny, activeSlide){                var options = {}                //scrolling down (moving sections up making them disappear)                if (xMovement === 'right') {                    var options = {                        translate3d: 'translate3d(0px, 0px, 0px)',                        scrolling: '0%',                        animateSection: destiny                    };                }                //scrolling up (moving section down to the viewport)                else {                    var options = {                        translate3d: 'translate3d(100%, 0px, 0px)',                        scrolling: '100%',                        animateSection: activeSlide                    };                }                return options;            };            self.afterSlideLoads = function(xMovement, slidesToMove, activeSlide, scrolling){                if(!options.css3){                     slidesToMove.each(function(index){                        if($(this).data('index') != activeSlide.data('index')){                            $(this).css('left', scrolling);                        }                    });                }            };            self.beforeMoveLeft = function(xMovement, slidesToMove, activeSlide, scrolling){                //moving the sections in between to the right position                if(xMovement == 'left'){                    slidesToMove.each(function(index){                        if($(this).data('index') != activeSlide.data('index')){                            $(this).css('left', scrolling);                        }                    });                }            };            self.onHorizontalPerform = function(animateSection, translate3d, animated){                //nothing            };            self.beforeMoveRight = function(xMovement, slidesToMove, activeSlide, scrolling){                //nothing            };            self.readjustHorizontalSections = function(xMovement, slidesToMove, scrolling){                if(xMovement === 'right'){                    slidesToMove.each(function(index){                        $(this).css('left', scrolling);                    });                }            };            //retrieves the top layer section when all sections are piled            self.getTopLayer = function(){                return $(SECTION_SEL).last();            };        }    };})(jQuery, document, window);